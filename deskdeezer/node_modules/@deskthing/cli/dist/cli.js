#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@deskthing/cli",
      version: "0.10.19",
      description: "An emulator for the DeskThing Server",
      keywords: [
        "Emulator",
        "DeskThing",
        "Development",
        "App",
        "Development",
        "DeskThing",
        "Development"
      ],
      exports: {
        ".": {
          import: "./dist/index.js",
          types: "./dist/index.d.ts"
        }
      },
      homepage: "https://github.com/itsriprod/deskthing-emulator#readme",
      bugs: {
        url: "https://github.com/itsriprod/deskthing-emulator/issues"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/itsriprod/deskthing-emulator.git"
      },
      license: "ISC",
      author: "Riprod",
      type: "module",
      main: "./dist/index.js",
      bin: {
        deskthing: "./dist/cli.js"
      },
      scripts: {
        build: "npm run build:emulator-client && npm run build:emulator && npm run build:cli && npm run build:emulator-thread && npm run build:index",
        "build:cli": "esbuild src/cli.ts --bundle --platform=node --outdir=dist --format=esm --packages=external",
        "build:emulator": "esbuild src/emulator/index.ts --bundle --platform=node --outdir=dist/emulator --format=esm --external:ws",
        "build:emulator-thread": "esbuild src/emulator/server/serverProcess.ts --bundle --platform=node --outdir=dist/emulator --format=esm --external:ts-node",
        "build:emulator-client": "vite build",
        "build:index": "esbuild src/index.ts --bundle --platform=node --outdir=dist --format=esm --packages=external && tsc src/index.ts --declaration --emitDeclarationOnly --outDir dist --skipLibCheck --isolatedModules --module ESNext"
      },
      dependencies: {
        "@vitejs/plugin-legacy": "^6.0.2",
        react: "^19.0.0",
        "react-dom": "^19.0.0",
        vite: "^6.2.2",
        ws: "^8.18.0",
        yargs: "^17.7.2",
        "zip-lib": "^1.0.5"
      },
      devDependencies: {
        "@deskthing/types": "file:../deskthing-types",
        "@types/node": "^22.10.10",
        "@types/react": "^19.0.8",
        "@types/react-dom": "^19.0.3",
        "@types/ws": "^8.5.14",
        "@types/yargs": "^17.0.33",
        "@vitejs/plugin-react": "^4.3.4",
        esbuild: "^0.25.1",
        "import-meta-resolve": "^4.1.0",
        typescript: "^5.7.3"
      },
      peerDependencies: {
        tsm: "^2.3.0"
      }
    };
  }
});

// src/cli.ts
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { fileURLToPath } from "url";
import { dirname, join as join8 } from "path";
import { execSync } from "child_process";

// src/package/package.ts
import { join as join2, resolve } from "path";
import zl from "zip-lib";
import { readdir, stat, cp, rm } from "fs/promises";

// src/package/config.ts
import { join } from "path";
import { readFileSync } from "fs";
var loadConfigs = () => {
  const packageJsonPath = join(process.cwd(), "package.json");
  const manifestJsonPath = join(process.cwd(), "deskthing/manifest.json");
  let packageJson;
  let manifestJson;
  try {
    packageJson = JSON.parse(readFileSync(packageJsonPath, "utf8"));
  } catch (error) {
    throw new Error(`\x1B[31mFailed to load package.json: ${error.message}\x1B[0m`);
  }
  try {
    manifestJson = JSON.parse(readFileSync(manifestJsonPath, "utf8"));
  } catch (error) {
    try {
      console.log("\x1B[33m\u274C Failed to load manifest.json from deskthing/manifest.json, trying public/manifest.json\x1B[0m");
      const oldmanifestJsonPath = join(process.cwd(), "public/manifest.json");
      manifestJson = JSON.parse(readFileSync(oldmanifestJsonPath, "utf8"));
      console.log("\x1B[32m\u2705 Successfully loaded manifest.json from public/manifest.json\x1B[0m");
    } catch (err2) {
      throw new Error(`\x1B[31mFailed to load manifest.json from both locations: ${error.message}, ${err2.message}\x1B[0m`);
    }
  }
  return {
    packageJson,
    manifestJson
  };
};

// src/package/package.ts
import { build as buildEsbuild } from "esbuild";
import { build as buildVite } from "vite";
import viteLegacyPlugin from "@vitejs/plugin-legacy";
async function buildServer() {
  await buildEsbuild({
    entryPoints: ["server/index.ts"],
    bundle: true,
    platform: "node",
    outfile: "dist/server/index.js",
    target: "ESNext",
    format: "esm",
    resolveExtensions: [".ts", ".js"],
    sourcemap: true,
    banner: {
      js: `
        // ESM shims for Node.js built-in modules
        import { createRequire } from 'module';
        import { fileURLToPath } from 'url';
        import path from 'path';
        
        const require = createRequire(import.meta.url);
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
      `
    }
  });
}
async function buildWorkers() {
  try {
    await stat("server/workers");
  } catch (e) {
    console.warn("\x1B[35mUnable to find workers file\x1B[0m");
    console.warn("\x1B[90m(Can be ignored if you do not have workers)\x1B[0m");
    return;
  }
  try {
    await buildEsbuild({
      entryPoints: ["server/workers/*.ts"],
      bundle: true,
      platform: "node",
      outdir: "dist/server/workers",
      target: "ESNext",
      format: "esm",
      resolveExtensions: [".ts", ".js"],
      sourcemap: true,
      banner: {
        js: `
          // ESM shims for Node.js built-in modules
          import { createRequire } from 'module';
          import { fileURLToPath } from 'url';
          import path from 'path';
          
          const require = createRequire(import.meta.url);
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = path.dirname(__filename);
        `
      }
    });
  } catch (error) {
    console.error("\x1B[31mError building workers:\x1B[0m", error);
  }
}
async function buildClient() {
  await buildVite({
    configFile: "vite.config.ts",
    base: "./",
    plugins: [viteLegacyPlugin({
      targets: ["Chrome 69"]
    })],
    build: {
      outDir: "dist/client",
      target: "es2020",
      rollupOptions: {
        output: {
          assetFileNames: "[name]-[hash][extname]",
          chunkFileNames: "[name]-[hash].js",
          entryFileNames: "[name]-[hash].js"
        }
      }
    }
  });
}
async function copyDeskThing() {
  const deskthingPath = resolve("deskthing");
  const publicPath = resolve("public");
  const distFile = resolve("dist");
  const manifestFile = join2(deskthingPath, "manifest.json");
  const oldmanifestFile = join2(publicPath, "manifest.json");
  if (await stat(manifestFile).catch(() => false)) {
    await cp(deskthingPath, join2(distFile), { recursive: true });
  } else if (await stat(oldmanifestFile).catch(() => false)) {
    console.log(
      "Using old manifest.json. Please move this to /deskthing or run `deskthing update`"
    );
    await cp(publicPath, join2(distFile), { recursive: true });
  } else {
    throw new Error("No manifest.json found in either /deskthing or /public");
  }
}
async function addFilesToArchive(archive, folderPath, baseFolder = "") {
  const exists = await stat(folderPath).catch(() => false);
  if (!exists) return;
  const files = await readdir(folderPath);
  for (const file of files) {
    const filePath = join2(folderPath, file);
    const stats = await stat(filePath);
    if (stats.isDirectory()) {
      await addFilesToArchive(archive, filePath, join2(baseFolder, file));
    } else {
      await archive.addFile(filePath, join2(baseFolder, file));
    }
  }
}
async function createPackage() {
  const { packageJson, manifestJson } = loadConfigs();
  const packageName = packageJson.name;
  const version = manifestJson.version || packageJson.version;
  const distPath = resolve("dist");
  const outputFile = join2(distPath, `${packageName}-v${version}.zip`);
  console.log("\x1B[36m%s\x1B[0m", "Zipping to " + outputFile);
  const archive = new zl.Zip();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F4E6} Adding files to archive...");
  await addFilesToArchive(archive, distPath);
  console.log("\x1B[33m%s\x1B[0m", "\u{1F4DD} Writing archive to file...");
  await archive.archive(outputFile);
  console.log("\x1B[32m%s\x1B[0m", "\u2705 Archive written successfully!");
}
async function clean() {
  const distPath = resolve("dist");
  const files = await readdir(distPath);
  for (const file of files) {
    const filePath = join2(distPath, file);
    await rm(filePath, { recursive: true, force: true });
  }
}
async function buildAll() {
  console.log("\x1B[33m%s\x1B[0m", "\u{1F9F9} Clearing dist folder...");
  await clean();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F3D7}\uFE0F Building Client...");
  await buildClient();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F3D7}\uFE0F Building Server...");
  await buildServer();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F3D7}\uFE0F Building Workers...");
  await buildWorkers();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F3D7}\uFE0F Copying Manifest...");
  await copyDeskThing();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F4E6} Creating package...");
  await createPackage();
  console.log("\x1B[32m%s\x1B[0m", "\u2705 Build completed successfully!");
}

// src/package/releaseMeta.ts
import { createHash } from "crypto";
import { existsSync, readFileSync as readFileSync2, writeFileSync } from "fs";
import { join as join3 } from "path";
var getLatestReleasesFromGithubURLs = (releaseAssetId, potentialUrls) => {
  for (const url of potentialUrls) {
    try {
      const githubMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
      if (githubMatch) {
        const [, owner, repo] = githubMatch;
        const cleanRepo = repo.replace(".git", "");
        return `https://github.com/${owner}/${cleanRepo}/releases/latest/download/${releaseAssetId}`;
      }
    } catch (error) {
      console.error("\x1B[90m%s\x1B[0m", "Error processing github URL:", error);
    }
  }
  return "";
};
var generateRelease = async () => {
  console.log("\x1B[33m%s\x1B[0m", "Reading package.json and manifest.json...");
  const { packageJson, manifestJson } = loadConfigs();
  console.log("\x1B[33m%s\x1B[0m", "Calculating package hash...");
  const packageName = packageJson.name;
  const version = manifestJson.version || packageJson.version;
  const distPath = join3(process.cwd(), "dist");
  const zipPath = join3(distPath, `${packageName}-v${version}.zip`);
  const iconPath = join3(distPath, "icons", `${manifestJson.id}.svg`);
  const iconPathAlt = join3(distPath, "images", `${manifestJson.id}.svg`);
  const iconFilePath = existsSync(iconPath) ? iconPath : existsSync(iconPathAlt) ? iconPathAlt : null;
  const icon = iconFilePath ? `data:image/svg+xml;base64,${readFileSync2(iconFilePath, "base64")}` : "";
  if (icon) {
    console.log("\x1B[33m%s\x1B[0m", "Icon found, adding to release metadata...");
  }
  const updateUrl = manifestJson.updateUrl || getLatestReleasesFromGithubURLs(
    `${packageName}-v${version}.zip`,
    [
      manifestJson.repository,
      packageJson.repository
    ]
  );
  let fileHash = "";
  let fileSize = -1;
  try {
    const fileBuffer = readFileSync2(zipPath);
    const hashSum = createHash("sha512");
    hashSum.update(fileBuffer);
    fileHash = hashSum.digest("hex");
    fileSize = fileBuffer.length;
  } catch (err) {
    console.warn("\x1B[33m%s\x1B[0m", "Could not generate hash for package file");
  }
  console.log("\x1B[33m%s\x1B[0m", "Generating release metadata...");
  const release = {
    id: manifestJson.id || "deskthingapp",
    label: manifestJson.label || packageJson.name || "",
    type: "single",
    version: `${version}`,
    description: manifestJson.description || packageJson.description || "",
    author: manifestJson.author || packageJson.author || "",
    platforms: manifestJson.platforms || ["windows", "mac", "linux"],
    homepage: manifestJson.homepage || packageJson.homepage || "",
    repository: manifestJson.repository || packageJson.repository?.url || "",
    updateUrl,
    tags: manifestJson.tags || ["webappOnly"],
    requiredVersions: manifestJson.requiredVersions || {
      server: `>=${manifestJson.compatible_server ? "0." + manifestJson.compatible_server : packageJson.version}`,
      client: `>=${manifestJson.compatible_client ? "0." + manifestJson.compatible_client : packageJson.version}`
    },
    icon,
    size: fileSize,
    hash: fileHash,
    hashAlgorithm: "sha512"
  };
  return release;
};
async function createReleaseFile() {
  console.log("\x1B[33m%s\x1B[0m", "Creating release file...");
  const distPath = join3(process.cwd(), "dist");
  const releaseFilePath = join3(distPath, `latest.json`);
  try {
    const release = await generateRelease();
    writeFileSync(releaseFilePath, JSON.stringify(release, null, 2));
    console.log("\x1B[32m%s\x1B[0m", "Release file created successfully");
  } catch (err) {
    console.error("\x1B[31m%s\x1B[0m", "Failed to create release file:", err);
  }
}

// src/package/index.ts
var packageApp = async ({ guided, noRelease, onlyRelease }) => {
  if (guided) {
    console.log("Guided mode is not implemented yet.");
    return;
  }
  if (!onlyRelease) {
    await buildAll();
  } else {
    console.log("\x1B[34m%s\x1B[0m", "\u23ED\uFE0F Skipping build step.");
  }
  if (!noRelease) {
    await createReleaseFile();
  } else {
    console.log("\x1B[34m%s\x1B[0m", "\u23ED\uFE0F Skipping release file creation step.");
  }
};

// src/packageClient/package.ts
import { join as join5, resolve as resolve2 } from "path";
import zl2 from "zip-lib";
import { readdir as readdir2, stat as stat2, rm as rm2 } from "fs/promises";

// src/packageClient/config.ts
import { join as join4 } from "path";
import { readFileSync as readFileSync3 } from "fs";
var loadConfigs2 = () => {
  const packageJsonPath = join4(process.cwd(), "package.json");
  const manifestJsPath = join4(process.cwd(), "public/manifest.json");
  let packageJson;
  let manifestJson;
  try {
    packageJson = JSON.parse(readFileSync3(packageJsonPath, "utf8"));
  } catch (error) {
    throw new Error(`\x1B[31mFailed to load package.json: ${error.message}\x1B[0m`);
  }
  try {
    const manifestContent = readFileSync3(manifestJsPath, "utf8");
    manifestJson = JSON.parse(manifestContent);
  } catch (error) {
    throw new Error(`\x1B[33m\u274C Failed to load manifest.json from ${manifestJsPath}. Does it exist?\x1B[0m`);
  }
  return {
    packageJson,
    manifestJson
  };
};

// src/packageClient/package.ts
import { build as buildVite2 } from "vite";
async function buildClient2() {
  await buildVite2({
    configFile: "vite.config.ts",
    base: "./"
  });
}
async function addFilesToArchive2(archive, folderPath, baseFolder = "") {
  const exists = await stat2(folderPath).catch(() => false);
  if (!exists) return;
  const files = await readdir2(folderPath);
  for (const file of files) {
    const filePath = join5(folderPath, file);
    const stats = await stat2(filePath);
    if (stats.isDirectory()) {
      await addFilesToArchive2(archive, filePath, join5(baseFolder, file));
    } else {
      await archive.addFile(filePath, join5(baseFolder, file));
    }
  }
}
async function createPackage2() {
  const { packageJson, manifestJson } = loadConfigs2();
  const packageName = packageJson.name;
  const version = (manifestJson.version || packageJson.version).replaceAll("v", "");
  const distPath = resolve2("dist");
  const outputFile = join5(distPath, `${packageName}-v${version}.zip`);
  console.log("\x1B[36m%s\x1B[0m", "Zipping to " + outputFile);
  const archive = new zl2.Zip();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F4E6} Adding files to archive...");
  await addFilesToArchive2(archive, distPath);
  console.log("\x1B[33m%s\x1B[0m", "\u{1F4DD} Writing archive to file...");
  await archive.archive(outputFile);
  console.log("\x1B[32m%s\x1B[0m", "\u2705 Archive written successfully!");
}
async function clean2() {
  const distPath = resolve2("dist");
  const files = await readdir2(distPath);
  for (const file of files) {
    const filePath = join5(distPath, file);
    await rm2(filePath, { recursive: true, force: true });
  }
}
async function buildAll2() {
  console.log("\x1B[33m%s\x1B[0m", "\u{1F9F9} Clearing dist folder...");
  await clean2();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F3D7}\uFE0F Building Client...");
  await buildClient2();
  console.log("\x1B[33m%s\x1B[0m", "\u{1F4E6} Creating package...");
  await createPackage2();
  console.log("\x1B[32m%s\x1B[0m", "\u2705 Build completed successfully!");
}

// src/packageClient/releaseMeta.ts
import { createHash as createHash2 } from "crypto";
import { existsSync as existsSync2, readFileSync as readFileSync4, writeFileSync as writeFileSync2 } from "fs";
import { join as join6 } from "path";

// src/packageClient/sanitizeData.ts
var sanitizeClient = async () => {
  console.log("\x1B[33m%s\x1B[0m", "\u{1F9F9} Client Sanitization not yet implemented...");
  console.log("\x1B[32m%s\x1B[0m", "\u2705 DeskThing sanitization completed successfully!");
};

// src/packageClient/releaseMeta.ts
var getLatestReleasesFromGithubURLs2 = (releaseAssetId, potentialUrls) => {
  for (const url of potentialUrls) {
    try {
      const githubMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
      if (githubMatch) {
        const [, owner, repo] = githubMatch;
        const cleanRepo = repo.replace(".git", "");
        return `https://github.com/${owner}/${cleanRepo}/releases/latest/download/${releaseAssetId}`;
      }
    } catch (error) {
      console.error("\x1B[90m%s\x1B[0m", "Error processing github URL:", error);
    }
  }
  return "";
};
var generateRelease2 = async () => {
  console.log("\x1B[33m%s\x1B[0m", "Reading package.json and manifest.json...");
  const { packageJson, manifestJson } = loadConfigs2();
  console.log("\x1B[33m%s\x1B[0m", "Calculating package hash...");
  const packageName = packageJson.name;
  const version = (manifestJson.version || packageJson.version).replaceAll("v", "");
  const distPath = join6(process.cwd(), "dist");
  const zipPath = join6(distPath, `${packageName}-v${version}.zip`);
  const iconPath = join6(distPath, "icons", `${manifestJson.id}.svg`);
  const iconPathAlt = join6(distPath, "images", `${manifestJson.id}.svg`);
  const iconFilePath = existsSync2(iconPath) ? iconPath : existsSync2(iconPathAlt) ? iconPathAlt : null;
  const icon = iconFilePath ? `data:image/svg+xml;base64,${readFileSync4(iconFilePath, "base64")}` : "";
  if (icon) {
    console.log("\x1B[33m%s\x1B[0m", "Icon found, adding to release metadata...");
  }
  const updateUrl = getLatestReleasesFromGithubURLs2(
    `${packageName}-v${version}.zip`,
    [
      manifestJson.repository,
      packageJson.repository
    ]
  );
  let fileHash = "";
  let fileSize = -1;
  try {
    const fileBuffer = readFileSync4(zipPath);
    const hashSum = createHash2("sha512");
    hashSum.update(fileBuffer);
    fileHash = hashSum.digest("hex");
    fileSize = fileBuffer.length;
  } catch (err) {
    console.warn("\x1B[33m%s\x1B[0m", "Could not generate hash for package file");
  }
  console.log("\x1B[33m%s\x1B[0m", "Generating release metadata...");
  const release = {
    id: manifestJson.id || "deskthingclient",
    version: `${version}`,
    label: manifestJson.name || packageJson.name || "",
    description: manifestJson.description || packageJson.description || "",
    author: manifestJson.author || packageJson.author || "",
    updateUrl,
    repository: manifestJson.repository || packageJson.repository || "",
    requiredServer: `>=${manifestJson.compatible_server ? "0." + manifestJson.compatible_server : packageJson.version}`,
    icon,
    size: fileSize,
    hash: fileHash,
    hashAlgorithm: "sha512",
    short_name: manifestJson.short_name,
    builtFor: manifestJson.builtFor
  };
  return release;
};
async function createReleaseFile2() {
  console.log("\x1B[33m%s\x1B[0m", "Creating release file...");
  const distPath = join6(process.cwd(), "dist");
  const releaseFilePath = join6(distPath, `latest.json`);
  try {
    await sanitizeClient();
    const release = await generateRelease2();
    writeFileSync2(releaseFilePath, JSON.stringify(release, null, 2));
    console.log("\x1B[32m%s\x1B[0m", "Release file created successfully");
  } catch (err) {
    console.error("\x1B[31m%s\x1B[0m", "Failed to create release file:", err);
  }
}

// src/packageClient/index.ts
var packageClient = async () => {
  await buildAll2();
  await createReleaseFile2();
};

// src/cli.ts
import { stat as stat3, writeFile } from "fs/promises";

// src/config/deskthing.config.ts
import { join as join7, resolve as resolve3 } from "path";
import { createRequire } from "module";
import { pathToFileURL } from "url";
var defaultConfig = {
  development: {
    logging: {
      level: "info",
      prefix: "[DeskThing Server]"
    },
    client: {
      logging: {
        level: "info",
        prefix: "[DeskThing Client]",
        enableRemoteLogging: true
      },
      clientPort: 3e3,
      viteLocation: "http://localhost",
      vitePort: 5173,
      linkPort: 8080
    },
    server: {
      editCooldownMs: 1e3,
      refreshInterval: 0
    }
  }
};
var getConfigFromFile = async (debug = false) => {
  try {
    const rootUrl = resolve3(process.cwd(), "deskthing.config.ts");
    const tsConfigPath = pathToFileURL(rootUrl).href;
    if (debug)
      console.log(
        `(debug mode enabled) Loading config from ${tsConfigPath} file...`
      );
    try {
      const configModule = await import(tsConfigPath);
      if (debug) console.log(`Config loaded successfully from ${tsConfigPath}`);
      return configModule.default || configModule;
    } catch (importError) {
      if (debug) console.log(`Direct import failed, trying alternative method...`);
      try {
        const require2 = createRequire(import.meta.url);
        try {
          require2("ts-node/register");
        } catch (e) {
        }
        const configModule = require2(rootUrl);
        return configModule.default || configModule;
      } catch (requireError) {
        if (debug) console.error(`All loading methods failed for ${rootUrl}`);
        throw importError;
      }
    }
  } catch (e) {
    if (debug)
      console.error("\x1B[91m(debug mode) Error loading config. Does it exist? :", e, "\x1B[0m");
    return null;
  }
};
var DeskThingConfig = defaultConfig;
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function deepmerge(target, source) {
  if (!isObject(target) || !isObject(source)) {
    return source;
  }
  const output = { ...target };
  for (const key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (isObject(source[key]) && isObject(target[key])) {
        output[key] = deepmerge(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    }
  }
  return output;
}
var initConfig = async (options = {
  silent: false,
  debug: false
}) => {
  try {
    const userConfig = await getConfigFromFile(options.debug);
    DeskThingConfig = deepmerge(defaultConfig, userConfig || {});
    if (!options.silent || options.debug) {
      if (userConfig) {
        console.log(`

\x1B[32m\u2705 Config Loaded\x1B[0m

`);
      } else {
        console.log(`

\x1B[32m\u2705 No Config Found, Using Default\x1B[0m`);
        if (options.debug) {
          console.log(
            `\x1B[3m\x1B[90mPath Checked: ${join7(
              process.cwd(),
              "deskthing.config.ts"
            )}\x1B[0m

`
          );
        }
      }
    }
  } catch (e) {
    if (options.debug)
      console.error("\x1B[91mError loading config:", e, "\x1B[0m");
  }
};
var serverConfig = {
  ...defaultConfig
};

// src/cli.ts
await initConfig({ silent: true });
var __dirname = dirname(fileURLToPath(import.meta.url));
var thisPackage = await Promise.resolve().then(() => __toESM(require_package(), 1)).catch(() => ({ default: { version: "0.0.0" } })).then((module) => module?.default) || { version: "0.0.0" };
console.log(`
  ------------------------------------------------
      _           _    _   _     \x1B[92m_\x1B[0m             
     | |         | |  | | | |   \x1B[92m(_)\x1B[0m            
   __| | ___  ___| | _| |_| |__  _ _ __   __ _ 
  / _\` |/ _ \\/ __| |/ / __| '_ \\| | '_ \\ / _\` |
 | (_| |  __/\\__ \\   <| |_| | | | | | | | (_| |
  \\__,_|\\___||___/_|\\_\\\\__|_| |_|_|_| |_|\\__, |
                                          __/ |
                                         |___/  
                Version ${thisPackage?.version || "0.10.7"}`);
yargs(hideBin(process.argv)).scriptName("deskthing").command("dev", "Start development server", (yargs2) => {
  return yargs2.option("debug", {
    type: "boolean",
    default: false,
    description: "Enable debug mode"
  });
}, async (argv) => {
  console.log(`------- \x1B[1mdev\x1B[0m -- init -- update -- package --------`);
  console.log("\n\n\x1B[1m\u{1F680} Starting development server...\x1B[0m\n\n");
  const tsmPath = join8(process.cwd(), "node_modules", "tsm");
  try {
    await stat3(tsmPath);
    console.log("\x1B[1mtsm is installed\x1B[0m\n");
  } catch (e) {
    console.log("\n\x1B[1mInstalling tsm dependency...\x1B[0m\n");
    execSync("npm install tsm --no-save --legacy-peer-deps", { stdio: "inherit" });
  }
  const indexPath = join8(__dirname, "./emulator/index.js");
  const fileUrl = `file://${indexPath.replace(/\\/g, "/")}`;
  const { startDevelopment } = await import(fileUrl);
  await startDevelopment({ debug: argv.debug });
}).command("update", "Update dependencies and configurations", (yargs2) => {
  return yargs2.option("force", {
    type: "boolean",
    default: false,
    description: "Force update all dependencies"
  });
}, async (argv) => {
  console.log(`------- dev -- init -- \x1B[1mupdate\x1B[0m -- package --------`);
  console.log("Updating dependencies and configurations...");
  execSync("npx create-deskthing@latest --update", { stdio: "inherit" });
}).command("package", "Package and zip up your app. Also generates needed manifest files", (yargs2) => {
  return yargs2.option("guided", {
    type: "boolean",
    default: false,
    description: "Force update all dependencies"
  }).option("no-release", {
    type: "boolean",
    default: false,
    description: "Skip generating release metadata files"
  }).option("only-release", {
    type: "boolean",
    default: false,
    description: "Only generate release metadata files"
  });
}, async (argv) => {
  console.log(`------- dev -- init -- update -- \x1B[1mpackage\x1B[0m --------`);
  console.log("Packaging app...");
  await packageApp({ guided: argv.guided, noRelease: argv.noRelease, onlyRelease: argv.onlyRelease });
}).command("package-client", "Package and zip up your client. Also generates needed manifest files", (yargs2) => {
  return yargs2;
}, async () => {
  console.log(`------- dev -- init -- update -- package --------
`);
  console.log(`-------           \x1B[1mpackaging client\x1B[0m       --------
`);
  await packageClient();
}).command("init", "Setup the DeskThing template", (yargs2) => {
  return yargs2;
}, async () => {
  console.log(`------- dev -- \x1B[1minit\x1B[0m -- update -- package --------`);
  console.log("Setting up the DeskThing template...");
  execSync("npm create deskthing@latest --create", { stdio: "inherit" });
}).command("$0", "Show available commands", () => {
  console.log(`------- dev -- init -- update -- package --------`);
  console.log("Available commands:");
  console.log("  dev       Start development server");
  console.log("  update    Update dependencies and configurations");
  console.log("  package   Package and zip up your app");
  console.log("  init  Setup the DeskThing template");
  console.log("\nRun `deskthing <command> --help` for more information about a command.");
}).command("init-config", "Create a typed configuration file", (yargs2) => {
  return yargs2;
}, async () => {
  console.log(`

------- \x1B[1mCreating typed configuration file\x1B[0m --------

`);
  const configTemplate = `
// version ${thisPackage?.version || "0.10.7"}
import { defineConfig } from '@deskthing/cli';

export default defineConfig({
  development: {
    logging: {
      level: "info",
      prefix: "[DeskThing Server]",
    },
    client: {
      logging: {
        level: "info",
        prefix: "[DeskThing Client]",
        enableRemoteLogging: true,
      },
      clientPort: 3000,
      viteLocation: "http://localhost",
      vitePort: 5173,
      linkPort: 8080,
    },
    server: {
      editCooldownMs: 1000,
    },
  }
});
  `;
  const configPath = join8(process.cwd(), "deskthing.config.ts");
  try {
    await writeFile(configPath, configTemplate);
    console.log(`

\x1B[32m\u2705 File created at
${configPath}\x1B[0m

`);
  } catch (error) {
    console.error("\x1B[31m\u274C Failed to create configuration file:\x1B[0m", error);
  }
}).parse();
